# OS-Garlyyev-Agajan
Вопросы и ответы:
1) Что такое ООП? – полное определение;
   Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции объектов,
   которые объединяют данные (атрибуты) и методы (функции) для их обработки. Основные принципы ООП:
   Инкапсуляция – сокрытие внутренней реализации и защита данных (например, private-поля в классе).
   Наследование – создание новых классов на основе существующих (class Child(Parent)).
   Полиморфизм – возможность объектов с одинаковым интерфейсом иметь разную реализацию (перегрузка методов, абстрактные классы).
   Абстракция – упрощение сложных систем через выделение ключевых характеристик (интерфейсы в Python).
2) Магическое число 7 Миллера
   Магическое число 7 Миллера – это когнитивное ограничение человека, связанное с краткосрочной памятью.
   Согласно исследованию психолога Джорджа Миллера (1956), человек способен одновременно удерживать в памяти около 7 (+/-2) элементов информации.
   Это ограничение часто учитывается при проектировании систем.
   Примеры из IT:
   Лимит вкладок в браузере – большинство пользователей не держат открытыми >7-9 вкладок.
   Меню навигации – сайты редко имеют >7 пунктов (например, GitHub: Pull requests, Issues, Marketplace и т.д.).
   Аргументы функции – PEP-8 рекомендует не более 5-7 параметров.
   Цветовая палитра UI – дизайнеры используют до 7 основных цветов.
   Опции в CLI – команды типа git имеют подкоманды (commit, push), но не сотни.
   Когнитивная нагрузка в коде – функции длиннее 7-10 строк сложнее воспринимать.
   Глубина вложенности – рекомендация не превышать 3-4 уровней (if/for внутри if/for).
3) Энтропия ПО
   Энтропия ПО – мера хаоса в коде, ведущая к росту сложности поддержки.
   Примеры негативных энтропийных мер:
   Дублирование кода: одинаковые фрагменты кода в разных частях системы усложняют сопровождение.
   Слабая документация: отсутствие комментариев и документации делает код непонятным для новых разработчиков.
   Сложные зависимости: чрезмерное количество зависимостей между модулями увеличивает риск ошибок.
   Нарушение принципов SOLID: неоправданная сложность и низкая модульность кода.
   Отсутствие тестов: отсутствие автоматизированных тестов приводит к снижению качества ПО.
4) 5 признаков сложной системы по Гради Бучу
    Иерархичность
   Пример 1: Веб-приложение (клиент ↔ сервер ↔ БД).
   Пример 2: Компилятор (лексический анализ → синтаксический → кодогенерация).
   Наличие подсистем
   Пример 1: CRM-система (модули: клиенты, заказы, аналитика).
   Пример 2: Игра (рендеринг, физика, AI).
   Эмерджентность (свойства системы ≠ сумме свойств частей)
   Пример 1: Баг в многопоточной программе (отдельные потоки работают, вместе — deadlock).
   Пример 2: Нейросеть (нейроны по отдельности не обучаются).
   Динамические связи
   Пример 1: API Gateway, маршрутизирующий запросы между сервисами.
   Пример 2: Плагины в IDE (подгружаются при запуске).
   Эволюция
   Пример 1: Миграция с монолита на микросервисы.
   Пример 2: Добавление кэширования в медленный сервис.
5) Закон иерархических компенсаций Седова
   Закон Седова: при усложнении одной части системы неизбежно упрощение другой части.
   Это связано с распределением сложности в системе.
   Примеры из IT:
   Появление высокоуровневых языков программирования: упрощение написания программ (Python, Java) за счет усложнения компиляторов.
   Микросервисы: упрощение разработки отдельных модулей за счет усложнения управления всей системой (например, оркестрация через Kubernetes).
   Графические интерфейсы: упрощение работы пользователей за счет усложнения реализации UI-фреймворков.
   Облачные технологии: упрощение управления инфраструктурой для пользователей за счет усложнения архитектуры облака.
   Искусственный интеллект: упрощение принятия решений для конечных пользователей за счет сложных алгоритмов и моделей машинного обучения.
   
